import os
import json
import base64
import traceback
import io
import time
import re

from flask import Flask, request, jsonify, send_file
from flask_cors import CORS

import google.generativeai as genai
from openai import OpenAI

app = Flask(__name__)
# Production'da buraya domain kısıtlaması ekleyebilirsin
CORS(app)

# --- KEYLER ---
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY", "").strip()
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY", "").strip()

if GEMINI_API_KEY:
    genai.configure(api_key=GEMINI_API_KEY)

client = OpenAI(api_key=OPENAI_API_KEY) if OPENAI_API_KEY else None

# --- GLOBAL CACHE ---
MODELS_CACHE = {"ts": 0, "data": []}
MODELS_CACHE_TTL = 600 

# --- YARDIMCILAR ---
def _dataurl_to_bytes(data_url: str):
    if not data_url or "," not in data_url: return None, None
    try:
        header, b64 = data_url.split(",", 1)
        mime = "image/jpeg"
        if header.startswith("data:") and ";base64" in header:
            mime = header[5:].split(";")[0].strip() or mime
        return mime, base64.b64decode(b64)
    except Exception as e:
        print(f"Resim hatası: {e}")
        return None, None

def get_available_models():
    now = time.time()
    if MODELS_CACHE["data"] and (now - MODELS_CACHE["ts"] < MODELS_CACHE_TTL):
        return MODELS_CACHE["data"]
    if not GEMINI_API_KEY: return []
    try:
        models_iter = genai.list_models()
        valid_models = []
        for m in models_iter:
            methods = getattr(m, "supported_generation_methods", []) or []
            if "generateContent" in methods:
                name = getattr(m, "name", "")
                if name: valid_models.append(name)
        real_list = sorted(list(set(valid_models)))
        MODELS_CACHE["ts"] = time.time()
        MODELS_CACHE["data"] = real_list
        return real_list
    except:
        return MODELS_CACHE["data"] if MODELS_CACHE["data"] else ["models/gemini-pro"]

def try_parse_json(txt: str):
    txt = (txt or "").strip().replace("```json", "").replace("```", "").strip()
    try: return json.loads(txt)
    except:
        # Regex ile JSON bloğunu bulmaya çalış
        m = re.search(r"\{[\s\S]*?\}", txt)
        if m:
            try: return json.loads(m.group(0))
            except: pass
        raise ValueError("Valid JSON not found")

def enforce_contract(out: dict) -> dict:
    if not isinstance(out, dict): out = {}
    
    if "headline" not in out: out["headline"] = "Analiz Tamamlandı"
    if "text" not in out: out["text"] = "Detaylı bilgi alınamadı."
    if "speech_text" not in out: out["speech_text"] = "Evladım, analiz bitti. Kaynanan sözü dinle, pişman olma..."
    if "product_img" not in out: out["product_img"] = ""

    # Score Clamp
    if "score" not in out or not isinstance(out["score"], dict):
        out["score"] = {"value": 50, "label": "Bilinmiyor", "color": "#F59E0B"}
    else:
        try: val = int(out["score"].get("value", 50))
        except: val = 50
        val = max(0, min(100, val))
        out["score"]["value"] = val
        
        # Renk mantığı
        if val >= 85: out["score"].update({"label":"Güvenle Yap", "color":"#10B981"})
        elif val >= 70: out["score"].update({"label":"Mantıklı", "color":"#3B82F6"})
        elif val >= 50: out["score"].update({"label":"Dikkat Et", "color":"#F59E0B"})
        else: out["score"].update({"label":"Uzak Dur", "color":"#EF4444"})

    # Indicators
    if "indicators" not in out: out["indicators"] = {}
    ind = out["indicators"]
    ind.setdefault("comment_trust", 50)
    ind.setdefault("chronic_issue", False)
    ind.setdefault("return_risk", "orta")

    # Lists
    for k in ["pros", "cons", "chronic_issues", "risk_flags", "evidence_quotes"]:
        if k not in out or not isinstance(out[k], list): out[k] = []
        out[k] = [str(x).strip() for x in out[k] if x]

    # Recommendations
    if "recommendations" not in out: out["recommendations"] = []
    safe_recs = []
    for r in out["recommendations"]:
        if not isinstance(r, dict): continue
        p_name = str(r.get("product_name") or "Öneri").strip()
        url = str(r.get("url") or "").strip()
        
        # Eğer link yoksa Google aramaya yönlendir (Mekanlar için)
        if not url:
            q_safe = p_name.replace(" ", "+")
            url = f"https://www.google.com/search?q={q_safe}"
        
        safe_recs.append({
            "product_name": p_name,
            "platform": str(r.get("platform") or "Genel").strip(),
            "site": str(r.get("site") or "Genel").strip(),
            "url": url,
            "award": str(r.get("award") or "Tavsiye").strip(),
            "reason": str(r.get("reason") or "").strip()
        })
    out["recommendations"] = safe_recs[:5]
    return out

# --- CAYNANA MANIFESTOSU (KENDİNİ TANIT İÇİN) ---
CAYNANA_INTRO = {
    "headline": "Ben Kimim Evladım?",
    "text": "Ben Kaynanan. Sadece alışverişte değil, hayatın her alanında yanındayım. Nereye gidilir, ne yenir, ne giyilir benden sorulur. Seni hatalı kararlardan, kazıkçı mekanlardan, üşütecek kıyafetlerden korumak için buradayım. Yapay zeka olabilirim ama tecrübem gerçektir!",
    "speech_text": "Evladım, ben Kaynanan... Sadece 'bu telefon alınır mı' diye sorma. 'Fethiye'de nerede yemek yenir?', 'Düzce'de nereye gidilir?', 'Bugün ne giysem?' diye de sor. Ben senin iyiliğin için varım. Seni gaza getirmem, gerçekleri söylerim. Kazık yeme, hasta olma, pişman olma diye buradayım. Kaynanan sözü dinle, pişman olma...",
    "score": {"value": 100, "label": "Hayat Koçun", "color": "#10B981"},
    "indicators": {"comment_trust": 100, "chronic_issue": False, "return_risk": "yok"},
    "pros": ["Her Şeyi Bilir", "Seni Korur", "Dobra"],
    "cons": ["Biraz Çok Konuşur", "Gerçekler Acıtır"],
    "chronic_issues": [],
    "risk_flags": [],
    "evidence_quotes": [],
    "recommendations": []
}

# --- SYSTEM PROMPT (GENİŞLETİLMİŞ DANIŞMAN MODU) ---
SYSTEM_INSTRUCTION = """
Sen Caynana'sın (Kullanıcıya kendini 'Kaynanan' olarak tanıt).
GÖREV: Kullanıcı ne sorarsa sorsun (Ürün, Mekan, Yemek, Kıyafet, Tavsiye), korumacı, iğneleyici ve uzman bir Türk Kaynanası gibi cevap ver.

SENARYOLAR VE DAVRANIŞLAR:
1. ÜRÜN SORARSA: Teknik analiz yap, kronik sorunları söyle, paranı çöpe atma de.
2. MEKAN/GEZİ SORARSA (Örn: Fethiye kahvaltı, Düzce gezilecek yer):
   - Turist tuzaklarına karşı uyar.
   - "Kazıkçı mekanlara gitme", "Reçeli marketten alan yere oturma" gibi uyarılarda bulun.
   - Doğa gezisi sorarsa "Yanına hırka al, üşütürsün", "Suya girme hasta olursun" gibi sağlık uyarıları ekle.
3. KIYAFET/MODA SORARSA (Örn: Bugün ne giyeyim?):
   - Havaya ve sağlığa odaklan. "O etekle donarsın", "Belini açık bırakma", "Ayağına yün çorap giy" gibi konuş. Modadan çok sağlığı düşün.

KURALLAR:
- SES TONU: Kadınsı, sevecen ama sert, otoriter, kinayeli.
- GÜVENLİK: "asdf", küfür, +18 sorulursa fırça at, analiz yapma.
- İMZA: speech_text MUTLAKA şu cümleyle bitmeli: "Kaynanan sözü dinle, pişman olma..."
- FORMAT: Sadece saf JSON.

JSON ALANLARI NASIL KULLANILACAK?
- product_name: Ürün adı VEYA Mekan adı VEYA Konu (örn: "Fethiye Kahvaltı")
- score: Alınabilirlik VEYA Gidilebilirlik VEYA Mantık Puanı
- chronic_issues: Ürün hatası VEYA Mekanın kötü yanı (örn: "Servis yavaş", "Porsiyon küçük", "Çok rüzgarlı")
- recommendations: Alternatif ürünler VEYA Alternatif mekanlar/aktiviteler.

İSTENEN JSON FORMATI:
{
  "headline": "Çarpıcı Başlık (Örn: Oraya Gidilir Ama...)",
  "text": "Detaylı analiz metni...",
  "product_img": "",
  "score": { "value": 0-100, "label": "Rozet", "color": "renk" },
  "indicators": { "comment_trust": 0-100, "chronic_issue": false, "return_risk": "düşük/orta/yüksek" },
  "pros": ["Artı 1", "Artı 2", "Artı 3"],
  "cons": ["Eksi 1", "Eksi 2", "Eksi 3"],
  "chronic_issues": ["Kronik sorun / Mekan sorunu"],
  "risk_flags": ["Fiyat / Hijyen / Hava Durumu"],
  "evidence_quotes": ["İlgili yorum/tavsiye"],
  "speech_text": "Evladım... (içerik)... Kaynanan sözü dinle, pişman olma...",
  "recommendations": [ { "product_name": "", "platform": "Google/Trendyol", "site": "Yer/Site", "url": "", "award": "", "reason": "" } ]
}
"""

@app.get("/")
def health(): return "Caynana API (Super App Mode)"

@app.get("/api/models")
def models():
    if not GEMINI_API_KEY:
        return jsonify({"ok": True, "llm_models": ["openai"], "default_llm": "openai", "tts": {"enabled": bool(client)}})
    
    available = get_available_models()
    clean = [m.replace("models/", "") for m in available] if available else ["gemini-pro"]
    
    # Varsayılan model seçimi
    default_m = "gemini-1.5-flash"
    for m in clean:
        if "gemini-2.0" in m: default_m = m; break
        if "gemini-1.5-pro" in m: default_m = m; break

    return jsonify({"ok": True, "llm_models": clean, "default_llm": default_m, "tts": {"enabled": bool(client)}})

@app.post("/api/analyze")
def analyze():
    try:
        data = request.get_json(silent=True) or {}
        query = (data.get("q") or "").strip()
        img_dataurl = data.get("img") or ""

        # --- ÖZEL SENARYO: KENDİNİ TANIT ---
        # Eğer kullanıcı "caynana kendini tanıt" butonuna bastıysa direkt hazır cevabı dön.
        if "caynana kendini tanıt" in query.lower() or "ben kimim" in query.lower():
            return jsonify(CAYNANA_INTRO)

        if not query and not img_dataurl:
            return jsonify({"error": True, "message": "Evladım boş boş bakma, bir şey sor."}), 400

        # LLM MODEL SEÇİMİ
        available = set(get_available_models())
        req_model = (data.get("model") or "").strip()
        models_to_try = []
        
        def norm(m): return m if m.startswith("models/") else "models/" + m
        
        if GEMINI_API_KEY:
            # Öncelik sırası
            candidates = [req_model, "gemini-1.5-pro", "gemini-2.0-flash", "gemini-1.5-flash", "gemini-pro"]
            for c in candidates:
                if not c: continue
                n = norm(c)
                if n in available and n not in models_to_try: models_to_try.append(n)
            if not models_to_try: models_to_try = ["models/gemini-pro"]

        text_resp = ""
        
        # 1. GEMINI İLE ANALİZ
        if GEMINI_API_KEY and models_to_try:
            parts = [f"Soru: {query}"]
            mime, img_bytes = _dataurl_to_bytes(img_dataurl)
            if img_bytes: parts.append({"mime_type": mime, "data": img_bytes})

            for m in models_to_try:
                try:
                    # Token limitini artırdık (Daha uzun yorum için)
                    model = genai.GenerativeModel(model_name=m, generation_config={"temperature": 0.5, "max_output_tokens": 2500, "response_mime_type": "application/json"}, system_instruction=SYSTEM_INSTRUCTION)
                    resp = model.generate_content(parts)
                    text_resp = (resp.text or "").strip()
                    if text_resp: break
                except: continue

        # 2. OPENAI FALLBACK (Gemini çalışmazsa)
        if not text_resp and client:
            try:
                sys_msg = SYSTEM_INSTRUCTION
                user_msg = f"Soru: {query}\n\nSADECE JSON."
                if img_dataurl: user_msg += " (Görsel var ama metin olarak analiz et)"
                
                resp = client.chat.completions.create(
                    model="gpt-4o-mini",
                    messages=[{"role": "system", "content": sys_msg}, {"role": "user", "content": user_msg}],
                    temperature=0.5,
                    max_tokens=2500
                )
                text_resp = resp.choices[0].message.content or ""
            except: pass

        if not text_resp:
            return jsonify({"headline": "Bağlantı Hatası", "text": "Sunuculara ulaşamıyorum evladım.", "score": {"value":0}}), 500

        try:
            out = try_parse_json(text_resp)
            return jsonify(enforce_contract(out))
        except:
            return jsonify(enforce_contract({"headline": "Hata", "text": text_resp[:500]}))

    except Exception as e:
        return jsonify({"error": True, "message": str(e)}), 500

@app.post("/api/speak")
def speak():
    try:
        if not client: return jsonify({"error": True, "message": "TTS Kapalı"}), 500
        data = request.get_json(silent=True) or {}
        text = (data.get("text") or "").strip()
        if not text: text = "Evladım sesim çıkmadı."
        
        # Telaffuz Düzeltme
        text = text.replace("Caynana", "Kaynanan").replace("caynana", "Kaynanan")

        # ZORUNLU İMZA KONTROLÜ (Garanti Olsun)
        if "kaynanan sözü dinle" not in text.lower():
            text += " Kaynanan sözü dinle, pişman olma..."

        # KADIN SESİ: NOVA
        resp = client.audio.speech.create(model="tts-1", voice="nova", input=text[:3000], response_format="mp3")
        
        try: audio_bytes = resp.read()
        except: audio_bytes = getattr(resp, "content", b"")
        
        return send_file(io.BytesIO(audio_bytes), mimetype="audio/mpeg", download_name="caynana.mp3")
    except Exception as e:
        return jsonify({"error": True, "message": str(e)}), 500

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.environ.get("PORT", "5000")))

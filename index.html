import os
import json
import base64
import traceback
import io
import time
import re

from flask import Flask, request, jsonify, send_file
from flask_cors import CORS

import google.generativeai as genai
from openai import OpenAI

app = Flask(__name__)
# Production'da buraya domain kısıtlaması ekleyebilirsin
CORS(app)

# --- KEYLER ---
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY", "").strip()
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY", "").strip()

if GEMINI_API_KEY:
    genai.configure(api_key=GEMINI_API_KEY)

client = OpenAI(api_key=OPENAI_API_KEY) if OPENAI_API_KEY else None

# --- GLOBAL CACHE ---
MODELS_CACHE = {"ts": 0, "data": []}
MODELS_CACHE_TTL = 600 

# --- YARDIMCILAR ---
def _dataurl_to_bytes(data_url: str):
    if not data_url or "," not in data_url: return None, None
    try:
        header, b64 = data_url.split(",", 1)
        mime = "image/jpeg"
        if header.startswith("data:") and ";base64" in header:
            mime = header[5:].split(";")[0].strip() or mime
        return mime, base64.b64decode(b64)
    except Exception as e:
        print(f"Resim hatası: {e}")
        return None, None

def get_available_models():
    now = time.time()
    if MODELS_CACHE["data"] and (now - MODELS_CACHE["ts"] < MODELS_CACHE_TTL):
        return MODELS_CACHE["data"]
    if not GEMINI_API_KEY: return []
    try:
        models_iter = genai.list_models()
        valid_models = []
        for m in models_iter:
            methods = getattr(m, "supported_generation_methods", []) or []
            if "generateContent" in methods:
                name = getattr(m, "name", "")
                if name: valid_models.append(name)
        real_list = sorted(list(set(valid_models)))
        MODELS_CACHE["ts"] = time.time()
        MODELS_CACHE["data"] = real_list
        return real_list
    except:
        return MODELS_CACHE["data"] if MODELS_CACHE["data"] else ["models/gemini-pro"]

def try_parse_json(txt: str):
    txt = (txt or "").strip().replace("```json", "").replace("```", "").strip()
    try: return json.loads(txt)
    except:
        # Regex ile JSON bloğunu bulmaya çalış
        m = re.search(r"\{[\s\S]*?\}", txt)
        if m:
            try: return json.loads(m.group(0))
            except: pass
        raise ValueError("Valid JSON not found")

def enforce_contract(out: dict) -> dict:
    if not isinstance(out, dict): out = {}
    
    if "headline" not in out: out["headline"] = "Analiz Tamamlandı"
    if "text" not in out: out["text"] = "Detaylı bilgi alınamadı."
    # DÜZELTME: speech_text varsayılanı 'Kaynanan' olarak güncellendi
    if "speech_text" not in out: out["speech_text"] = "Evladım, analiz bitti. Kaynanan sözü dinle, pişman olma..."
    if "product_img" not in out: out["product_img"] = ""

    # Score Clamp
    if "score" not in out or not isinstance(out["score"], dict):
        out["score"] = {"value": 50, "label": "Bilinmiyor", "color": "#F59E0B"}
    else:
        try: val = int(out["score"].get("value", 50))
        except: val = 50
        val = max(0, min(100, val))
        out["score"]["value"] = val
        
        # Renk mantığı
        if val >= 85: out["score"].update({"label":"Güvenle Al", "color":"#10B981"})
        elif val >= 70: out["score"].update({"label":"Mantıklı", "color":"#3B82F6"})
        elif val >= 50: out["score"].update({"label":"Dikkat Et", "color":"#F59E0B"})
        else: out["score"].update({"label":"Uzak Dur", "color":"#EF4444"})

    # Indicators
    if "indicators" not in out: out["indicators"] = {}
    ind = out["indicators"]
    ind.setdefault("comment_trust", 50)
    ind.setdefault("chronic_issue", False)
    ind.setdefault("return_risk", "orta")

    # Lists
    for k in ["pros", "cons", "chronic_issues", "risk_flags", "evidence_quotes"]:
        if k not in out or not isinstance(out[k], list): out[k] = []
        out[k] = [str(x).strip() for x in out[k] if x]

    # Recommendations
    if "recommendations" not in out: out["recommendations"] = []
    safe_recs = []
    for r in out["recommendations"]:
        if not isinstance(r, dict): continue
        p_name = str(r.get("product_name") or "Ürün").strip()
        url = str(r.get("url") or "").strip()
        
        # Trendyol Link Zorlaması
        if ("trendyol.com" not in url) and ("ty.gl" not in url):
            q_safe = (p_name or "urun").replace(" ", "+")
            url = f"https://www.trendyol.com/sr?q={q_safe}"
        
        safe_recs.append({
            "product_name": p_name,
            "platform": "Trendyol",
            "site": "Trendyol",
            "url": url,
            "award": str(r.get("award") or "Öneri").strip(),
            "reason": str(r.get("reason") or "").strip()
        })
    out["recommendations"] = safe_recs[:5]
    return out

# --- CAYNANA MANIFESTOSU (KENDİNİ TANIT İÇİN) ---
CAYNANA_INTRO = {
    "headline": "Ben Kimim Evladım?",
    "text": "Ben Caynana. Yapay zeka destekli, lafını esirgemeyen, seni hatalı alışverişten korumaya ant içmiş bir alışveriş asistanıyım. Satıcıların süslü laflarına kanmam, binlerce yorumu okur, kronik sorunları şak diye yüzüne vururum. Amacım sana ürün satmak değil, paranı çer çöpe harcamanı engellemek.",
    # DÜZELTME: Konuşma metninde "Ben Kaynanan" yazıldı.
    "speech_text": "Evladım, ben Kaynanan... Hani o internette görüp de 'acaba alınır mı' dediğin ürünler var ya? İşte ben onların ciğerini bilirim. Satıcıların 'süper, harika' demesine bakmam; binlerce yorumu tarar, kronik arızası var mı, iadesi zor mu, hepsini senin yerine araştırırım. Seni gaza getirip ürün satmaya değil, paranı korumaya geldim. Hatalı karar verip sonra üzülme diye buradayım. Kaynanan sözü dinle, pişman olma...",
    "score": {"value": 100, "label": "Canın Ciğerin", "color": "#10B981"},
    "indicators": {"comment_trust": 100, "chronic_issue": False, "return_risk": "düşük"},
    "pros": ["Dobra ve Gerçekçi", "Seni Korur", "7/24 Analiz Yapar"],
    "cons": ["Biraz Çok Konuşur", "Gerçekler Acıtır"],
    "chronic_issues": [],
    "risk_flags": [],
    "evidence_quotes": [],
    "recommendations": []
}

# --- SYSTEM PROMPT (KARAKTER & GÜVENLİK AYARLARI) ---
SYSTEM_INSTRUCTION = """
Sen Caynana'sın. Türkiye'nin en dobra alışveriş asistanısın.

GÖREV: Kullanıcının sorduğu ürünü analiz et ve JSON formatında yanıtla.

KURALLAR:
1. SES TONU: Kadınsı, sevecen ama hafif iğneleyici/kinayeli. Teknik konularda çok detaylı ve uzman ol.
2. GÜVENLİK (ÇOK ÖNEMLİ):
   - Eğer kullanıcı "asdf", "qwe", "sadasd" gibi anlamsız tuşlara bastıysa: Puanı 0 ver, "Evladım klavyenin üzerine mi oturdun? Düzgün bir şey yaz da bakalım." gibi kinayeli bir cevap dön.
   - Eğer kullanıcı +18, küfür, hakaret, yasadışı ürün veya şiddet içeren bir şey sorarsa: Puanı 0 ver, "Terbiyesizliğin lüzumu yok evladım, git ağzını çalkala gel." de. Analiz yapma.
3. FORMAT: Sadece saf JSON. Markdown yok.
4. LİNKLER: Sadece Trendyol linkleri.
5. KAPANIŞ (SPEECH_TEXT İÇİN ÇOK ÖNEMLİ): 
   - speech_text alanı "Evladım" ile başlamalı.
   - speech_text alanında kendini ASLA "Caynana" olarak tanıtma, "Kaynanan" olarak tanıt. (Telaffuz için K harfi şart).
   - MUTLAKA şu cümleyle bitmeli: "Kaynanan sözü dinle, pişman olma..."

İSTENEN JSON FORMATI:
{
  "headline": "Çarpıcı Başlık",
  "text": "Detaylı, uzun ve teknik analiz metni...",
  "product_img": "",
  "score": { "value": 0-100, "label": "Rozet", "color": "renk" },
  "indicators": { "comment_trust": 0-100, "chronic_issue": false, "return_risk": "düşük/orta/yüksek" },
  "pros": ["Artı 1", "Artı 2", "Artı 3"],
  "cons": ["Eksi 1", "Eksi 2", "Eksi 3"],
  "chronic_issues": ["Kronik sorun 1"],
  "risk_flags": ["Fiyat Yüksek", "Yedek Parça Yok"],
  "evidence_quotes": ["Kullanıcı yorumu 1"],
  "speech_text": "Evladım... (analiz)... Kaynanan sözü dinle, pişman olma...",
  "recommendations": [ { "product_name": "", "platform": "Trendyol", "site": "Trendyol", "url": "", "award": "", "reason": "" } ]
}
"""

@app.get("/")
def health(): return "Caynana API (Karakter Modu: Kaynanan)"

@app.get("/api/models")
def models():
    if not GEMINI_API_KEY:
        return jsonify({"ok": True, "llm_models": ["openai"], "default_llm": "openai", "tts": {"enabled": bool(client)}})
    
    available = get_available_models()
    clean = [m.replace("models/", "") for m in available] if available else ["gemini-pro"]
    
    # Varsayılan model seçimi
    default_m = "gemini-1.5-flash"
    for m in clean:
        if "gemini-2.0" in m: default_m = m; break
        if "gemini-1.5-pro" in m: default_m = m; break

    return jsonify({"ok": True, "llm_models": clean, "default_llm": default_m, "tts": {"enabled": bool(client)}})

@app.post("/api/analyze")
def analyze():
    try:
        data = request.get_json(silent=True) or {}
        query = (data.get("q") or "").strip()
        img_dataurl = data.get("img") or ""

        # --- ÖZEL SENARYO: KENDİNİ TANIT ---
        # Eğer kullanıcı "caynana kendini tanıt" butonuna bastıysa direkt hazır cevabı dön.
        if "caynana kendini tanıt" in query.lower() or "ben kimim" in query.lower():
            return jsonify(CAYNANA_INTRO)

        if not query and not img_dataurl:
            return jsonify({"error": True, "message": "Evladım boş boş bakma, bir şey sor."}), 400

        # LLM MODEL SEÇİMİ
        available = set(get_available_models())
        req_model = (data.get("model") or "").strip()
        models_to_try = []
        
        def norm(m): return m if m.startswith("models/") else "models/" + m
        
        if GEMINI_API_KEY:
            # Öncelik sırası
            candidates = [req_model, "gemini-1.5-pro", "gemini-2.0-flash", "gemini-1.5-flash", "gemini-pro"]
            for c in candidates:
                if not c: continue
                n = norm(c)
                if n in available and n not in models_to_try: models_to_try.append(n)
            if not models_to_try: models_to_try = ["models/gemini-pro"]

        text_resp = ""
        
        # 1. GEMINI İLE ANALİZ
        if GEMINI_API_KEY and models_to_try:
            parts = [f"Soru: {query}"]
            mime, img_bytes = _dataurl_to_bytes(img_dataurl)
            if img_bytes: parts.append({"mime_type": mime, "data": img_bytes})

            for m in models_to_try:
                try:
                    # Token limitini artırdık (Daha uzun yorum için)
                    model = genai.GenerativeModel(model_name=m, generation_config={"temperature": 0.4, "max_output_tokens": 2500, "response_mime_type": "application/json"}, system_instruction=SYSTEM_INSTRUCTION)
                    resp = model.generate_content(parts)
                    text_resp = (resp.text or "").strip()
                    if text_resp: break
                except: continue

        # 2. OPENAI FALLBACK (Gemini çalışmazsa)
        if not text_resp and client:
            try:
                sys_msg = SYSTEM_INSTRUCTION
                user_msg = f"Soru: {query}\n\nSADECE JSON."
                if img_dataurl: user_msg += " (Görsel var ama metin olarak analiz et)"
                
                resp = client.chat.completions.create(
                    model="gpt-4o-mini",
                    messages=[{"role": "system", "content": sys_msg}, {"role": "user", "content": user_msg}],
                    temperature=0.4,
                    max_tokens=2500
                )
                text_resp = resp.choices[0].message.content or ""
            except: pass

        if not text_resp:
            return jsonify({"headline": "Bağlantı Hatası", "text": "Sunuculara ulaşamıyorum evladım, sonra gel.", "score": {"value":0}}), 500

        try:
            out = try_parse_json(text_resp)
            return jsonify(enforce_contract(out))
        except:
            return jsonify(enforce_contract({"headline": "Hata", "text": text_resp[:500]}))

    except Exception as e:
        return jsonify({"error": True, "message": str(e)}), 500

@app.post("/api/speak")
def speak():
    try:
        if not client: return jsonify({"error": True, "message": "TTS Kapalı"}), 500
        data = request.get_json(silent=True) or {}
        text = (data.get("text") or "").strip()
        if not text: text = "Evladım sesim çıkmadı."
        
        # DÜZELTME: Telaffuz için "Caynana" kelimeleri "Kaynanan" olarak değiştiriliyor.
        text = text.replace("Caynana", "Kaynanan").replace("caynana", "Kaynanan")

        # ZORUNLU İMZA KONTROLÜ (Garanti Olsun)
        if "kaynanan sözü dinle" not in text.lower():
            text += " Kaynanan sözü dinle, pişman olma..."

        # KADIN SESİ: NOVA
        resp = client.audio.speech.create(model="tts-1", voice="nova", input=text[:3000], response_format="mp3")
        
        try: audio_bytes = resp.read()
        except: audio_bytes = getattr(resp, "content", b"")
        
        return send_file(io.BytesIO(audio_bytes), mimetype="audio/mpeg", download_name="caynana.mp3")
    except Exception as e:
        return jsonify({"error": True, "message": str(e)}), 500

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.environ.get("PORT", "5000")))
